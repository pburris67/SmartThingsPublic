/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "04.04.02"
}

/*
* This is the device type code for a z-wave customized thermostat with battery status, humidity, clock set, up-down tiles and icons.
* Base code has been synchronized with SmartThings as of Aug 2017
*
* Thermostat with Temperature, Humidity and Auto Time setting
*
* Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
*
* Change log:
* 2018-12-26 - (v04.04.02) Fix for ZTS-xxx deadband settings
* 2018-12-04 - (v04.04.01) Use a single tile for lock control/air filter to save space
* 2018-12-03 - (v04.04.00) Added support for ZTS filter counter/resetting
* 2018-10-31 - (v04.03.03) Fix for CT-80 thermostat models with battery and clock firmware bug
* 2018-10-24 - (v04.03.02) Fix for ZTS-500 broken secure comms with new hub firmware update
* 2018-10-05 - (v04.03.01) Show more logging in recently tab
* 2018-09-22 - (v04.03.00) Added support for locking controls and update status every 1 or 12 hours
* 2018-09-06 - (v04.02.05) Report DH version more often
* 2018-08-23 - (v04.02.04) Refix for CTxx Auto mode
* 2018-08-08 - (v04.02.03) Updated support for new ST app
* 2018-08-05 - (v04.02.02) Added health check capability
* 2018-08-02 - (v04.02.01) Added basic support for new ST app
* 2018-07-27 - (v04.02.00) Fix for Auto mode not working on some CTxx thermostats, include C-Wire state in summary
* 2018-07-16 - (v04.01.01) Fix for settings heating and cooling setpoint simultaneously when location is in Celsius and improve sync with CT-xx thermostats
* 2018-07-05 - (v04.00.01) Work around for CT-xx firmware bug when switching heat to cool or vice versa, only use platform default polling by default
* 2017-11-22 - (v04.00.00) Added support for secure devices communication and ZTS-500
* 2017-11-07 - (v03.01.02) Reduce deadband to 1 degree (F and C) and limit defective firmware to CT30e firmware only
* 2017-10-30 - (v03.01.01) Removed SimpleUI mode because it also messes up the scheduling to make it day specific and doesn't work with ST
* 2017-10-29 - (v03.01.00) Added support for enabling and disabling Simple UI on CT-XX
* 2017-10-19 - (v03.00.04) Added support for the CT-100 Plus thermostat
* 2017-10-18 - (v03.00.03) Update tile layout with ST mobile app release 2.8.0
* 2017-09-25 - (v03.00.02) Added single decimal precision to show temperature reported from thermostats
* 2017-08-28 - (v03.00.01) Added the quickSetHeat and quickSetCool commands back for backwards compatibility (even thought ST made them redundant) and fix Emergency Heat
* 2017-08-26 - (v03.00.00) State change reduce duplicate logging and updated base code
* 2017-05-15 - (v02.07.01) Improved the layout to change background colors based to state of HVAC
* 2017-05-03 - (v02.07.00) Updated DTH to reflect new attributes changed by ST, added device health check and updated icons
* 2017-05-03 - (v02.06.00) Harmonized color scheme to match ST, show correct state of fan and operating, added color for Auto Fan on
* 2017-04-10 - (v2.5.4) Improved summary tile layout hvac status
* 2017-03-20 - (v2.5.4) Added CT-30 Brown Box MSR/fingerprints
* 2017-03-12 - (v2.5.3) Fix for 2.3.1 ST Android app broken UI
* 2017-02-27 - (v2.5.3) Added GoControl signature
* 2016-11-02 - Added ability to check for new code versions
* 2016-11-02 - Added Â° symbol to the temperature
* 2016-10-19 - Added more fingerprints for Ct-30 variants
* 2016-09-19 - Added more fingerprints
* 2016-09-15 - Added support for v2 style fingerprints and check for defective z-wave module for CT-XXX which shows the wrong clock and adjust for it
* 2016-08-23 - Updated battery icon
* 2016-06-25 - Added more CT-101/CT-30 fingerprints and MSR codes for CT-101/CT-30
* 2016-05-15 - Notify use if timezone/location is missing in setup
* 2016-05-04 - Added CT-30 support for identification, added support for all CT-XXX models
* 2016-04-20 - Added DH version in setup page
* 2016-04-17 - Debug discovery code
* 2016-03-29 - Added CT-101 fingerprint
* 2016-03-28 - Added CT-30 fingerprint
* 2016-03-28 - Fixed bug with Fan showing 'null' in the summary line or not showing accurate state
* 2016-03-28 - Improved reliable of configure button to program thermostat parameters
* 2016-03-28 - Added fingerprints for CT-100 and ZTS-110 for automatic setup when adding new thermostats
* 2016-03-16 - Let system set temperature units (don't force to F)
* 2016-03-15 - Added support to configure reporting threshold, swing and calibration for CT-XXX and ZTS-110 thermostats
* 2016-02-10 - Improve polling handler when skipping polling
* 2016-02-06 - Bugfix for configure throwing error
* 2016-02-06 - Fixed refresh on configuration
* 2016-02-02 - Add initialization on settings update
* 2016-01-28 - Pressing Mode and Auto no longer goes into hunting mode, only one command at a time
* 2016-01-28 - Fix for Level Up/down for Android
* 2016-01-27 - Fix for ST iOS 2.0.8 release breaking Battery UI
* 2016-01-24 - Updated base code to 2016-1-24 (emergency heat is now emergencyHeat)
* 2016-01-24 - Bugfix for error on handling invalid / empty z-wave multiInstance command
* 2016-01-02 - Temporary workaround for ? showing up on Android 2.0.7
* 2015-12-06 - ST fixed the VALUE_CONTROL issues with the iOS release 2.0.5, reenabling it
* 2015-10-23 - VALUE_CONTROL causes the new ST app to crash, so disabled this feature until ST fixes their crappy app
* 2015-09-26 - Added color palette for Humidity
* 2015-09-23 - Updated layout and colors
* 2015-09-19 - Added support for MultiAttributeTiles
* 2015-08-07 - Fix for polling stopping when in battery save mode
* 2015-07-25 - Report change in state when operating state and fan state change
* 2015-07-22 - Updated to sync with ST base code
* 2015-07-12 - Fixed issue with battery and humidity not being reported
* 2015-07-09 - Added support fot battery save mode to reduce polling frequency to 30 minutes
* 2015-06-07 - Fix for Humidity not working (thanks @schettj)
* 2015-04-24 - Fix to supporting C and F for temp up/down
* 2015-02-10 - Added capability for battery
* 2015-02-03 - Updated base code to 2015-2-3, support for thermostatFanState attribute and Emergency Heat, added sliders for temp to make faster changes
* 2015-01-01 - Fix for battery update
* 2014-11-01 - Humidity, Battery update, Auto time setting
*
*  Copyright 2014 SmartThings
*
*  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
*  in compliance with the License. You may obtain a copy of the License at:
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
*  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
*  for the specific language governing permissions and limitations under the License.
*
*
*/

metadata {
    // Automatically generated. Make future change here.
    definition (name: "Enhanced Z-Wave Plus Thermostat with Temperature, Humidity and Auto Time setting", ocfDeviceType: "oic.d.thermostat", namespace: "rboy", author: "RBoy Apps", mnmn: "SmartThings", vid:"SmartThings-smartthings-Z-Wave_Thermostat") {
        capability "Actuator"
        capability "Temperature Measurement"
        capability "Relative Humidity Measurement"
        capability "Thermostat"
        capability "Configuration"
        capability "Polling"
        capability "Sensor"
        capability "Refresh"
        capability "Battery"
        capability "Power Source"
        capability "Health Check"

        attribute "thermostatFanState", "string"
        attribute "thermStatus", "string"
        attribute "fanState", "string"
        attribute "deadBand", "number"
        attribute "setFilter", "number"
        attribute "sharedTile1", "string"
        attribute "codeVersion", "string"
        attribute "dhName", "string"

        command "switchMode"
        command "switchFanMode"
        command "raiseHeatingSetpoint"
        command "lowerHeatingSetpoint"
        command "raiseCoolSetpoint"
        command "lowerCoolSetpoint"
        command "levelUpDown"
        command "levelUp"
        command "levelDown"
        command "quickSetCool"
        command "quickSetHeat"
        command "lockControls"
        command "partialLockControls"
        command "unlockControls"
        command "resetFilter"

        fingerprint deviceId: "0x08"
        fingerprint inClusters: "0x43,0x40,0x44,0x31"
        fingerprint inClusters: "0x20,0x31,0x40,0x42,0x43,0x44,0x45,0x47,0x70,0x72,0x80,0x81,0x85,0x86" // ZTS-110
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x44,0x43,0x42,0x86,0x70,0x80,0x88" // CT-30
        fingerprint inClusters: "0x20,0x87,0x72,0x31,0x40,0x44,0x43,0x42,0x86,0x70,0x80,0x88" // CT-30 (rebadged model from alarm company)
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x42,0x44,0x45,0x43,0x86,0x70,0x80,0x85,0x60" // CT-100, CT-101 (Lowe's version)
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x42,0x44,0x45,0x43,0x86,0x70,0x80,0x85,0x5D,0x60" // CT-101

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"08" // Generic Thermostat
        fingerprint cc:"43,40,44,31" // Generic Thermostat
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", deviceJoinName:"CT-10X Z-Wave Thermostat" // Generic CT-100/101 Thermostat
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6401", model:"0107", deviceJoinName:"CT-100 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6401", model:"0106", deviceJoinName:"CT-100 Z-Wave Vivint Thermostat" // Vivint
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6501", model:"000C", deviceJoinName:"CT-101 Z-Wave Lowes Thermostat" // Lowes
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,5D,60", mfr:"0098", prod:"6501", model:"000C", deviceJoinName:"CT-101 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"1E10", model:"0158", deviceJoinName:"CT-30 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"0000", model:"0000", deviceJoinName:"CT-30 Rebadged Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"1E12", model:"015C", deviceJoinName:"CT-30e Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,31,40,42,43,44,45,47,70,72,80,81,85,86", mfr:"5254", prod:"0200", model:"8031", deviceJoinName:"ZTS-110 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"5E,98,72,5A,86,59,20", ccOut:"20", sec:"7A,85,70,73,31,40,42,43,44,45", mfr:"5254", prod:"0200", model:"8170", deviceJoinName:"ZTS-500 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85", mfr:"0098", prod:"1E12", model:"015E", deviceJoinName:"CT-30 Generic Rev C1 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"3200", model:"015E", deviceJoinName:"Filtrete 3M-50 (CT-50) Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"001E", deviceJoinName:"APX CT-30 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"0000", deviceJoinName:"CT-30 Brown Box Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"00FF", deviceJoinName:"CT-30 Brown Box Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"00FF", deviceJoinName:"CT-30 Brown Box Z-Wave Thermostat"
        fingerprint type:"0806", cc:"5E,5D,81,87,59,31,7A,40,42,44,45,43,70,80,85,8E,86,73,5A,72", mfr:"0098", prod:"6402", model:"0100", deviceJoinName:"CT-100 Plus Radio Thermostat"
        fingerprint type:"0806", cc:"40,42,43,44,45,80,70,31,8F,86,72,85,2C,2B,73,81", mfr:"014F", prod:"5442", model:"5431", deviceJoinName:"GoControl GC-TBZ48 Z-Wave Thermostat"
        fingerprint type:"0806", mfr:"0098", prod:"5003", model:"0109", deviceJoinName:"CT-80 Z-Wave Thermostat" // zw:L type:0806 mfr:0098 prod:5003 model:0109 ver:9.00 zwv:3.28 lib:03 cc:20,81,87,72,31,40,42,44,45,43,86,70,85,60 epc:2 ep:['0806 31,85']  
        fingerprint type:"0806", mfr:"0098", prod:"5003", model:"01FD", deviceJoinName:"CT-80 Z-Wave Thermostat"
        fingerprint mfr:"0039", prod:"0011", model:"0001", deviceJoinName: "Honeywell Z-Wave Thermostat" // Honeywell
    }

    preferences {
        input title: "", description: "Z-Wave Thermostat Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "batterySaveMode", "bool", title: "Save thermostat battery", description: "Enable this to reduce polling frequency to no more than once in 30 minutes to save thermostat battery", required: true, displayDuringSetup: true
        input title: "", description: "This section is used to configure the CT-xxx thermostats (CT30/CT32/CT50/CT80/CT100/CT101/CT110)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "autoTempDiffCT", "enum", title: "Temperature change reporting threshold", description: "Set the temperature change reporting threshold", multiple: false, defaultValue: "1.0Â°F", options: ["Disabled","0.5Â°F","1.0Â°F","1.5Â°F","2.0Â°F"], required: false, displayDuringSetup: true
        input "swingCT", "enum", title: "Temperature swing", description: "Set the temperature swing threshold", multiple: false, defaultValue: "1.0Â°F", options: ["0.5Â°F","1.0Â°F","1.5Â°F","2.0Â°F","2.5Â°F","3.0Â°F","3.5Â°F","4.0Â°F"], required: false, displayDuringSetup: true
        input title: "", description: "This section is used to configure parameters for the ZTS-xxx thermostats", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "autoTempDiffZTS", "enum", title: "Temperature change reporting threshold", description: "Set the temperature change reporting threshold", multiple: false, defaultValue: "4.0Â°F", options: ["Disabled","1.0Â°F","2.0Â°F","3.0Â°F","4.0Â°F","5.0Â°F","6.0Â°F","7.0Â°F","8.0Â°F"], required: false, displayDuringSetup: true
        input "swingZTS", "enum", title: "Temperature swing", description: "Set the temperature swing threshold", multiple: false, defaultValue: "2.0Â°F", options: ["1.0Â°F","2.0Â°F","3.0Â°F","4.0Â°F"], required: false, displayDuringSetup: true
        input "tempCalibrationZTS", "enum", title: "Temperature correction", description: "Set the temperature calibration", multiple: false, defaultValue: "0Â°F", options: ["-10Â°F","-9Â°F","-8Â°F","-7Â°F","-6Â°F","-5Â°F","-4Â°F","-3Â°F","-2Â°F","-1Â°F","0Â°F","1Â°F","2Â°F","3Â°F","4Â°F","5Â°F","6Â°F","7Â°F","8Â°F","9Â°F","10Â°F"], required: false, displayDuringSetup: true
        input "deadbandZTS", "enum", title: "Dead band", description: "Minimum gap between heating and cooling setpoint", multiple: false, defaultValue: "4Â°F", options: ["3Â°F","4Â°F","5Â°F","6Â°F"], required: false, displayDuringSetup: true
        input "filterZTS", "number", title: "Filter hours", description: "Number of hours between filter replacement notifications", multiple: false, defaultValue: "500", range: "500..4000", required: false, displayDuringSetup: true
    }

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "thermostat", width: 6, height: 4){
            tileAttribute ("device.temperature", key: "PRIMARY_CONTROL") {
                attributeState("temperature", label:'${currentValue}Â°', defaultState: true)
            }
            tileAttribute ("device.thermStatus", key: "SECONDARY_CONTROL") {
                attributeState("thermStatus", label:'${currentValue}', icon: "st.arlo.sensor_battery_4", defaultState: true)
            }
            tileAttribute ("device.level", key: "VALUE_CONTROL") {
                attributeState("default", action: "levelUpDown")
                attributeState("VALUE_UP", action: "levelUp")
                attributeState("VALUE_DOWN", action: "levelDown")
            }
            tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
                attributeState("idle", backgroundColor:"#cccccc")
                attributeState("heating", backgroundColor:"#e86d13")
                attributeState("cooling", backgroundColor:"#00A0DC")
            }
            /*tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
                attributeState("off", label:'${name}')
                attributeState("heat", label:'${name}')
                attributeState("cool", label:'${name}')
                attributeState("auto", label:'${name}')
            }
            tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
                attributeState("heatingSetpoint", label:'${currentValue}', defaultState: true)
            }
            tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
                attributeState("coolingSetpoint", label:'${currentValue}', defaultState: true)
            }*/
        }
        valueTile("temperature", "device.temperature", width: 4, height: 4) {
            state("temperature", label:'${currentValue}Â°',
                  backgroundColors:[
							// Celsius
							[value: 0, color: "#153591"],
							[value: 7, color: "#1e9cbb"],
							[value: 15, color: "#90d2a7"],
							[value: 23, color: "#44b621"],
							[value: 28, color: "#f1d801"],
							[value: 35, color: "#d04e00"],
							[value: 37, color: "#bc2323"],
							// Fahrenheit
							[value: 40, color: "#153591"],
							[value: 44, color: "#1e9cbb"],
							[value: 59, color: "#90d2a7"],
							[value: 74, color: "#44b621"],
							[value: 84, color: "#f1d801"],
							[value: 95, color: "#d04e00"],
							[value: 96, color: "#bc2323"]
					]
                 )
        }
        standardTile("mode", "device.thermostatMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false, decoration: "flat") {
            state "off", action:"switchMode", nextState:"...", icon: "st.thermostat.heating-cooling-off"
            state "heat", action:"switchMode", nextState:"...", icon: "st.thermostat.heat", backgroundColor: '#e86d13'
            state "cool", action:"switchMode", nextState:"...", icon: "st.thermostat.cool", backgroundColor: '#00a0dc'
            state "auto", action:"switchMode", nextState:"...", icon: "st.thermostat.auto"
            state "emergency heat", action:"switchMode", nextState:"...", icon: "st.thermostat.emergency-heat", backgroundColor: '#E11102'
            state "...", label: "...", nextState:"..."
        }
        standardTile("fanMode", "device.fanState", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false, decoration: "flat") {
            state "autoOff", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-auto", defaultState: true
            state "autoOn", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-auto", backgroundColor: '#00f78c'
            state "on", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-on", backgroundColor: '#00f78c'
            state "circulate", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-circulate", backgroundColor: '#02D2E1'
            state "...", label: "...", nextState:"..."
        }
        controlTile("heatSliderControl", "device.heatingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "heat", action:"setHeatingSetpoint", backgroundColor:"#e86d13"
        }
        standardTile("heatingSetpoint", "device.heatingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "heat", label:'${currentValue}Â°', backgroundColor: '#e86d13'
        }
        controlTile("coolSliderControl", "device.coolingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "cool", action:"setCoolingSetpoint", backgroundColor: "#00a0dc"
        }
        standardTile("coolingSetpoint", "device.coolingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "cool", label:'${currentValue}Â°', backgroundColor: '#00a0dc'
        }
        standardTile("refresh", "command.refresh", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "default", action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "configure", label:'', action:"configuration.configure", icon:"st.secondary.configure"
        }
        standardTile("raiseHeatingSetpoint", "device.raiseHeatingSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "raiseHeatingSetpoint", label:'Heat', action:"raiseHeatingSetpoint", icon:"st.thermostat.thermostat-up"
        }
        standardTile("lowerHeatingSetpoint", "device.lowerHeatingSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "lowerHeatingSetpoint", label:'Heat', action:"lowerHeatingSetpoint", icon:"st.thermostat.thermostat-down"
        }
        standardTile("raiseCoolSetpoint", "device.raiseCoolSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "raiseCoolSetpoint", label:'Cool', action:"raiseCoolSetpoint", icon:"st.thermostat.thermostat-up"
        }
        standardTile("lowerCoolSetpoint", "device.lowerCoolSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "lowerCoolSetpoint", label:'Cool', action:"lowerCoolSetpoint", icon:"st.thermostat.thermostat-down"
        }
        valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'${currentValue}%', unit: "", icon: "http://smartthings.rboyapps.com/images/battery.png", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        valueTile("humidity", "device.humidity", width: 2, height: 2, inactiveLabel: false) {
            state "humidity", label:' ${currentValue}%', icon:"st.Weather.weather12", backgroundColors: [
                [value: 20, color: "#ffe700"],
                [value: 30, color: "#d6ff00"],
                [value: 45, color: "#3cff00"],
                [value: 60, color: "#00ffb8"],
                [value: 80, color: "#00dfff"]
            ]
        }        
        standardTile("sharedTile1", "device.sharedTile1", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false, decoration: "flat") {
            state "", label:'${currentValue} hours', action: "resetFilter", nextState:"...", icon:"http://smartthings.rboyapps.com/images/AirFilter.png", defaultState: true
            state "0", label:'Replace', action: "resetFilter", nextState:"...", icon:"http://smartthings.rboyapps.com/images/AirFilter.png"
            state "unsupported", label: '', backgroundColor: '#ffffff'
            state "disabled", label: '', action: "partialLockControls", nextState:"...", icon: "http://smartthings.rboyapps.com/images/ControlsUnlocked.png", backgroundColor: '#ffffff'
            state "partial", label: 'Partial', action: "lockControls", nextState:"...", icon: "http://smartthings.rboyapps.com/images/ControlsPartialLocked.png", backgroundColor: '#ffffff'
            state "full", label: 'Full', action: "unlockControls", nextState:"...", icon: "http://smartthings.rboyapps.com/images/ControlsLocked.png", backgroundColor: '#ffffff'
            state "...", label: "Resetting", nextState:"..."
        }
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }

        main "summary"
        details(["summary", "mode", "fanMode", "humidity", "heatingSetpoint", "lowerHeatingSetpoint", "raiseHeatingSetpoint", "heatSliderControl", "coolingSetpoint", "lowerCoolSetpoint", "raiseCoolSetpoint", "coolSliderControl", "sharedTile1", "refresh", "battery"])
    }
}

def installed() {
    log.trace "Installed called"
    sendEvent(name:"powerSource", value: "unknown") // Default power source is unknown
	// Configure device
	def cmds = [new physicalgraph.device.HubAction(command(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:[zwaveHubNodeId]))),
			new physicalgraph.device.HubAction(zwave.manufacturerSpecificV2.manufacturerSpecificGet().format())]
	sendHubCommand(cmds)
	runIn(3, "initialize", [overwrite: true])  // Allow configure command to be sent and acknowledged before proceeding
}

def updated() {
    log.trace "Updated called"
	// If not set update ManufacturerSpecific data
	if (!getDataValue("manufacturer")) {
		sendHubCommand(new physicalgraph.device.HubAction(zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()))
		runIn(2, "initialize", [overwrite: true])  // Allow configure command to be sent and acknowledged before proceeding
	} else {
		initialize()
	}
}

def initialize() {
	// Device-Watch simply pings if no device events received for 32min(checkInterval)
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
	/*unschedule()
	if (getDataValue("manufacturer") != "Honeywell") {
		runEvery5Minutes("poll")  // This is not necessary for Honeywell Z-wave, but could be for other Z-wave thermostats
	}*/ // Not required, Z-Wave thermostats push rather than poll
    if (batterySaveMode) { // Poll every 12 hours
        schedule("* 0 */12 * * ?", scheduledPoll) // Poll every 12 hours, some devices don't report
    } else {
        schedule("* 0 */1 * * ?", scheduledPoll) // Poll every 1 hour, some devices don't report
    }
	sendHubCommand(response(configure()).toHubAction()) // Send command since this can be called from a schedule
}

/**
 * PING is used by Device-Watch in attempt to reach the Device
 * */
def ping() {
	log.debug "ping() called"
	// Just get Operating State as it is not reported when it changes and there's no need to flood more commands
	sendHubCommand(new physicalgraph.device.HubAction(command(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet())))
}

def parse(String description) {
	def result = []
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Z-Wave Thermostat with Temperature, Humidity and Auto Time Setting Device Handler"]) // Save DH Name for parent app
	if (description.startsWith("Err 106")) {
        log.warn("Z-Wave error '$description'")
		state.sec = 0
		result << createEvent(descriptionText: description, isStateChange: true)
	} else if (description != "updated") {
		def zwcmd = zwave.parse(description, [0x42:1, 0x43:2, 0x31:3, 0x70:2, 0x98:1]) // Thermostat Operating State:1, Thermostat Setpoint:2, Sensor Multilevel:3, Configuration:2, Security:1
		if (zwcmd) {
			result << zwaveEvent(zwcmd)
            //log.trace "Parse returned $result"
		} else {
			log.warn "$device.displayName couldn't parse $description"
		}
	}

    //def thermStatusS = "System ${device.currentValue('thermostatOperatingState')} | Fan ${device.currentValue('thermostatFanState')} | Battery ${device.currentValue('battery')}%"
    def source = ""
    switch (device.currentValue('powerSource')) {
        case "mains":
        	source = "C-Wire"
            break
            
        case "battery":
        default:
        	source = device.currentValue('battery') + "%"
            break
    }
    def thermStatusS = "${source}"
    //log.trace thermStatusS
    sendEvent(name: "thermStatus", value: thermStatusS, displayed: false) // Return the status

    def fanStateS
    if (device.currentValue('thermostatFanMode') == "auto") {
        if (device.currentValue('thermostatFanState') != "idle") {
            fanStateS = "autoOn"
        } else {
            fanStateS = "autoOff"
        }
    } else {
        fanStateS = device.currentValue('thermostatFanMode')
    }
    //log.trace "Fan state: $fanStateS"
    sendEvent(name: "fanState", value: fanStateS)
	
    return result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
    //log.trace "SecurityMessageEncapsulation $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand([0x42:1, 0x43:2, 0x31:3, 0x70:2]) // Thermostat Operating State:1, Thermostat Setpoint:2, Sensor Multilevel:3, Configuration:2
	if (encapsulatedCommand) {
        state.sec = 1
		zwaveEvent(encapsulatedCommand)
	}
}

private command(physicalgraph.zwave.Command cmd) {
    //log.trace cmd
    //log.trace "Secure: $state.sec"
	if (state.sec) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private commands(commands, delay=300) { // Some of these params need more time to get on this switch or they are dropped
	delayBetween(commands.collect{ command(it) }, delay)
}

// Event Generation
def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd) {
    log.trace "$cmd"

    def cmdScale = cmd.scale == 1 ? "F" : "C"
	def setpoint = getTempInLocalScale(cmd.scaledValue, cmdScale)
	def unit = getTemperatureScale()
	switch (cmd.setpointType) {
		case 1:
			sendEvent(name: "heatingSetpoint", value: setpoint, unit: unit, displayed: false)
			updateThermostatSetpoint("heatingSetpoint", setpoint)
			break;
		case 2:
			sendEvent(name: "coolingSetpoint", value: setpoint, unit: unit, displayed: false)
			updateThermostatSetpoint("coolingSetpoint", setpoint)
			break;
		default:
			log.debug "unknown setpointType $cmd.setpointType"
			return
	}
	// So we can respond with same format
	state.size = cmd.size
	state.scale = cmd.scale
	state.precision = cmd.precision
	// Make sure return value is not result from above expresion
	return 0
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv3.SensorMultilevelReport cmd) {
    log.trace "$cmd"

	def map = [:]
	if (cmd.sensorType == 1) {
        map.value = convertTemperatureIfNeeded(cmd.scaledSensorValue?.toBigDecimal(), cmd.scale == 1 ? "F" : "C")?.toDouble()?.round(cmd.precision ? 1 : 0) // Keep upto one decimal point for compatibility with newer thermostats with improved precision reporting
		map.unit = getTemperatureScale()
		map.name = "temperature"
		updateThermostatSetpoint(null, null)
	} else if (cmd.sensorType == 5) {
		map.value = cmd.scaledSensorValue
		map.unit = "%"
		map.name = "humidity"
	}
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatOperatingState"]
	switch (cmd.operatingState) {
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_IDLE:
			map.value = "idle"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_HEATING:
			map.value = "heating"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_COOLING:
			map.value = "cooling"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_FAN_ONLY:
			map.value = "fan only"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_HEAT:
			map.value = "pending heat"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_COOL:
			map.value = "pending cool"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_VENT_ECONOMIZER:
			map.value = "vent economizer"
			break
	}
	// Makes sure we have the correct thermostat mode
	sendHubCommand(new physicalgraph.device.HubAction(command(zwave.thermostatModeV2.thermostatModeGet())))
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanstatev1.ThermostatFanStateReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatFanState", unit: ""]
	switch (cmd.fanOperatingState) {
		case 0:
			map.value = "idle"
			break
		case 1:
			map.value = "running"
			break
		case 2:
			map.value = "running high"
			break
	}
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatMode", data:[supportedThermostatModes: state.supportedModes]]
	switch (cmd.mode) {
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_OFF:
			map.value = "off"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_HEAT:
			map.value = "heat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUXILIARY_HEAT:
			map.value = "emergency heat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_COOL:
			map.value = "cool"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUTO:
			map.value = "auto"
			break
	}
	sendEvent(map)
	updateThermostatSetpoint(null, null)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatFanMode", data:[supportedThermostatFanModes: state.supportedFanModes]]
	switch (cmd.fanMode) {
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_AUTO_LOW:
			map.value = "auto"
			break
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_LOW:
			map.value = "on"
			break
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_CIRCULATION:
			map.value = "circulate"
			break
	}
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeSupportedReport cmd) {
    log.trace "$cmd"

	def supportedModes = []

	if(cmd.heat) { supportedModes << "heat" }
	if(cmd.cool) { supportedModes << "cool" }
	// Make sure off is before auto, this ensures the right setpoint is used based on current temperature when auto is set
	if(cmd.off) { supportedModes << "off" }
	if(cmd.auto) { supportedModes << "auto" }
	if(cmd.auxiliaryemergencyHeat) { supportedModes << "emergency heat" }

	state.supportedModes = supportedModes
	sendEvent(name: "supportedThermostatModes", value: supportedModes, displayed: false)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeSupportedReport cmd) {
    log.trace "$cmd"

	def supportedFanModes = []
	if(cmd.auto) { supportedFanModes << "auto" }
	if(cmd.low) { supportedFanModes << "on" }
	if(cmd.circulation) { supportedFanModes << "circulate" }

	state.supportedFanModes = supportedFanModes
	sendEvent(name: "supportedThermostatFanModes", value: supportedFanModes, displayed: false)
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
    log.trace "$cmd"

	if (cmd.manufacturerName) {
		updateDataValue("manufacturer", cmd.manufacturerName)
	}
	if (cmd.productTypeId) {
		updateDataValue("productTypeId", cmd.productTypeId.toString())
	}
	if (cmd.productId) {
		updateDataValue("productId", cmd.productId.toString())
	}
    
    def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
    log.debug "msr: $msr"
    updateDataValue("MSR", msr)
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd) {
	log.debug "Zwave BasicReport: $cmd"
}

def zwaveEvent(physicalgraph.zwave.commands.multichannelv3.MultiInstanceCmdEncap cmd) {
    def encapsulatedCommand = cmd?.encapsulatedCommand([0x31: 3]) // Encapsulate Sensor Multi Level (0x31) and use Version 3 of the class
    log.trace ("multichannelv3.MultiInstanceCmdEncap: command from instance ${cmd?.instance}: ${encapsulatedCommand}")
    if (encapsulatedCommand) {
        return zwaveEvent(encapsulatedCommand)
    } else {
        log.warn "multichannelv3.MultiInstanceCmdEncap: unrecognized command $cmd"
    }
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
    log.trace "$cmd"

    def map = [ name: "battery", unit: "%" ]
    if (state.noBattery) { // If there is no battery in this model then report it as 100% to avoid a low battery notification
        log.trace "Device $state.MSR has no battery, reporting 100%"
        map.value = 100
    } else if (cmd.batteryLevel == 0xFF || cmd.batteryLevel == 0) {
        map.value = 1
        map.descriptionText = "battery is low!"
    } else {
        map.value = cmd.batteryLevel
    }
    sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
    log.trace "$cmd"

    def result = []
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	def text = "$device.displayName: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	result << createEvent(descriptionText: text, isStateChange: false)
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) {
    log.trace "$cmd"
    
    def events = []
    
    if (isCT()) {
        events << processCTConfigReport(cmd)
    } else if (isZTS()) {
        events << processZTSConfigReport(cmd)
    }
    
    events?.flatten()
}

private processCTConfigReport(cmd) {
    //log.trace "Processing CT Config report"
    
    switch (cmd.parameterNumber) {
        case ctParamMap.TempReport.Param:
            def msg = "Temperature change reporting threshold: ${(cmd.configurationValue[0]) * 0.5}Â°F" // Max value is 4 in increments of 0.5Â°F (filter the rest out)
            sendEvent(name: "temperatureChangeReport", value: (cmd.configurationValue[0]) * 0.5, descriptionText: msg, displayed: true)
            log.trace msg
            break

        case ctParamMap.HumidityReport.Param:
            def msg = "Humidity change reporting threshold: ${(cmd.configurationValue[0]) * 0.5}%" // Max value is 3 in increments of 0.5% (filter the rest out)
            sendEvent(name: "humidityChangeReport", value: (cmd.configurationValue[0]) * 0.5, descriptionText: msg, displayed: true)
            log.trace msg
            break

        case ctParamMap.CWire.Param:
        	def value
        	switch (cmd.configurationValue[0]) {
                case ctParamMap.CWire.Enabled:
                	value = "mains"
                    break
                    
                case ctParamMap.CWire.Disabled:
                	value = "battery"
                	break
                    
                default:
                	value = "unknown"
                    break
            }
            def msg = "C-Wire state: ${value}"
            sendEvent(name: "powerSource", value: value, descriptionText: msg) // Only display if changed since it's called from poll()
            log.trace msg
            break

        case ctParamMap.TempSwing.Param:
            def msg = "Temperature swing: ${(cmd.configurationValue[0]) * 0.5}Â°F" // Max value is 8 in increments of 0.5Â°F (filter the rest out)
            sendEvent(name: "temperatureSwing", value: (cmd.configurationValue[0]) * 0.5, descriptionText: msg, displayed: true)
            log.trace msg
            break

        case ctParamMap.SimpleUIMode.Param:
            def msg = "Simple UI is ${cmd.configurationValue[0] ? "enabled" : "disabled"}"
            sendEvent(name: "simpleUI", value: "${cmd.configurationValue[0] ? "enabled" : "disabled"}", descriptionText: msg, displayed: true)
            log.trace msg
            break
            
        case ctParamMap.UtilityLock.Param:
        	def map = [ name: "lockControls" ]
            def msg = ""
        	switch(cmd.configurationValue[0]) {
                case ctParamMap.UtilityLock.Disabled:
                    msg = "Thermostat controls unlocked"
                    map.value = "disabled"
                    break
                
                case ctParamMap.UtilityLock.Partial:
                    msg = "Thermostat controls partially locked"
                    map.value = "partial"
                    break
                
                case ctParamMap.UtilityLock.Full:
                default:
                    msg = "Thermostat controls fully locked"
                    map.value = "full"
                    break
            }
            map.descriptionText = msg
            sendEvent(map)
            sendEvent(name: "sharedTile1", value: map.value, displayed: false) // Don't display shared tile value
        	log.trace msg
        	break

        default:
            break    
    }

    [] // No events to return
}

private processZTSConfigReport(cmd) {
    //log.trace "Processing ZTS Config report"
    
    def type
    switch (state.MSR) {
        case "5254-0200-8170": // ZTS-500
            type = "getZts500ParamMap"
            break

        case "5254-0200-8031": // ZTS-110
            type = "getZts100ParamMap"
            break

        default:
            log.warn "Unsupported ZTS model ${state.MSR}"
            return []
    }

    def scale = getTemperatureScale()
    def scaleMultiplier = (scale == "F" ? 1.0 : 0.5)
    switch (cmd.parameterNumber) { // Common to all ZTS-XXX models
        case "${type}"().Swing.Param:
            def msg = "Temperature swing: ${"${type}"(cmd.configurationValue).Swing.Value * scaleMultiplier}Â°${scale}" // Max value is 4 in increments of 1.0Â°F/0.5Â°C (filter the rest out)
            sendEvent(name: "temperatureSwing", value: "${type}"(cmd.configurationValue).Swing.Value, descriptionText: msg, displayed: true)
            log.trace msg
            break

        case "${type}"().TempAutoReport.Param:
            def msg = "Temperature change reporting threshold: ${"${type}"(cmd.configurationValue).TempAutoReport.Value * scaleMultiplier}Â°${scale}" // Max value is 8 in increments of 1.0Â°F/0.5Â°C (filter the rest out)
            sendEvent(name: "temperatureChangeReport", value: "${type}"(cmd.configurationValue).TempAutoReport.Value, descriptionText: msg, displayed: true)
            log.trace msg
            break

        case "${type}"().TempOffset.Param:
            def msg = "Temperature calibration correction: ${"${type}"(cmd.configurationValue).TempOffset.Value * scaleMultiplier}Â°${scale}"
            sendEvent(name: "temperatureCalibration", value: "${type}"(cmd.configurationValue).TempOffset.Value, descriptionText: msg, displayed: true)
            log.trace msg
            break
            
        case "${type}"().ReportFilter.Param: // this reports elapsed hours since last reset
            def usage = "${type}"(cmd.configurationValue).ReportFilter.Value
            def threshold = (device.currentValue("setFilter") ?: "${type}"().SetFilter.Default) as Long // Get the configured setFilter value or use default if not set yet
            def remaining = Math.max(0, threshold - usage) // Calculate the remaining hours down to 0
            def msg = "Filter usage: ${threshold} hours, replacement due in ${remaining} hours"
            sendEvent(name: "reportFilter", value: usage, descriptionText: msg) // Only show if the value has changed since it's called from poll
            sendEvent(name: "sharedTile1", value: "${remaining}", isStateChange: true, displayed: false) // Force a state change so that the ... goes away, no need to show
            log.trace msg
            break
            
        case "${type}"().SetFilter.Param:
            def msg = "Filter replacement life: ${"${type}"(cmd.configurationValue).SetFilter.Value} hours"
            sendEvent(name: "setFilter", value: "${type}"(cmd.configurationValue).SetFilter.Value, descriptionText: msg, displayed: true)
            log.trace msg
            break
            
        default:
            break
    }
    
    if (type == "getZts500ParamMap") { // ZTS 500 specific configuration
        switch (cmd.parameterNumber) {
            case "${type}"().TempScaleInF.Param:
                log.trace "Temperature scale in ${"${type}"(cmd.configurationValue).TempScaleInF.Value ? "F" : "C"}"
                break

            case "${type}"().DeadBand.Param:
                def msg = "DeadBand: ${"${type}"(cmd.configurationValue).DeadBand.Value * scaleMultiplier}Â°${scale}"
                sendEvent(name: "deadBand", value: "${type}"(cmd.configurationValue).DeadBand.Value * scaleMultiplier, descriptionText: msg, displayed: true)
                log.trace msg
                break

            default:
                break    
        }
    }
    
    [] // No events to return
}


def zwaveEvent(physicalgraph.zwave.Command cmd) {
    log.warn "Unexpected zwave command $cmd"
}

// Configuration
def setConfigParameters() {
    def cmds = []

    if (isCT()) {
        cmds += configureCT()
    } else if (isZTS()) {
        cmds += configureZTS()
    }

    cmds ? commands(cmds, 2000) : []
}

private configureZTS() {
    def cmds = []
    def type
    switch (state.MSR) {
        case "5254-0200-8170": // ZTS-500
            type = "getZts500ParamMap"
            break

        case "5254-0200-8031": // ZTS-110
            type = "getZts100ParamMap"
            break
        
        default:
            log.warn "Unsupported ZTS model ${state.MSR}"
            return []
    }
    
    if (type == "getZts500ParamMap") { // ZTS 500 specific configuration
        if (true) { // Always set the temperature scale on thermostat to match hub
            def tempScale = getTemperatureScale()
            log.debug "Setting Thermostat Temperature Scale to $tempScale"
            def paramName = "TempScaleInF"
            def paramValue
            if (tempScale == "F") {
                paramValue = 1
            } else {
                paramValue = 0
            }

            //cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: "${type}"()."${paramName}".Param, size: "${type}"()."${paramName}".Size, configurationValue: "${type}"(paramValue)."${paramName}".ParamValue)
            cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Verify after
        }
        
        if (settings.deadbandZTS) {
            log.debug "Setting new value of Dead Band to $settings.deadbandZTS"
            def paramName = "DeadBand"
            def paramValue
            switch (settings.deadbandZTS) {
                case "3Â°F":
                    paramValue = 3
                    break
                case "4Â°F":
                    paramValue = 4
                    break
                case "5Â°F":
                    paramValue = 5
                    break
                case "6Â°F":
                    paramValue = 6
                    break
                default:
                    paramValue = 4 // Default 4Â°F / 2Â°C
	                break
            }

            //cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: "${type}"()."${paramName}".Param, size: "${type}"()."${paramName}".Size, configurationValue: "${type}"(paramValue)."${paramName}".ParamValue)
            cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Verify after
        }
    }

	if (settings.autoTempDiffZTS) {
        log.debug "Setting new value of Auto Temp Change Report to $settings.autoTempDiffZTS"
        def paramName = "TempAutoReport"
        def paramValue
        switch (settings.autoTempDiffZTS) {
            case "Disabled":
                paramValue = 0
                break
            case "1.0Â°F":
                paramValue = 1
                break
            case "2.0Â°F":
                paramValue = 2
                break
            case "3.0Â°F":
                paramValue = 3
                break
            case "4.0Â°F":
                paramValue = 4
                break
            case "5.0Â°F":
                paramValue = 5
                break
            case "6.0Â°F":
                paramValue = 6
                break
            case "7.0Â°F":
                paramValue = 7
                break
            case "8.0Â°F":
                paramValue = 8
                break
            default:
                paramValue = 2 // Default 2.0Â°F / 1Â°C
	            break
        }

        //cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Check before
        cmds << zwave.configurationV2.configurationSet(parameterNumber: "${type}"()."${paramName}".Param, size: "${type}"()."${paramName}".Size, configurationValue: "${type}"(paramValue)."${paramName}".ParamValue)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Verify after
    }

    if (settings.tempCalibrationZTS) {
        log.debug "Setting new value of Temperature Calibration to $settings.tempCalibrationZTS"
        def paramName = "TempOffset"
        def paramValue
        switch (settings.tempCalibrationZTS) {
            case "-10Â°F":
                paramValue = 0xF6
                break
            case "-9Â°F":
                paramValue = 0xF7
                break
            case "-8Â°F":
                paramValue = 0xF8
                break
            case "-7Â°F":
                paramValue = 0xF9
                break
            case "-6Â°F":
                paramValue = 0xFA
                break
            case "-5Â°F":
                paramValue = 0xFB
                break
            case "-4Â°F":
                paramValue = 0xFC
                break
            case "-3Â°F":
                paramValue = 0xFD
                break
            case "-2Â°F":
                paramValue = 0xFE
                break
            case "-1Â°F":
                paramValue = 0xFF
                break
            case "0Â°F":
                paramValue = 0
                break
            case "1Â°F":
                paramValue = 0x01
                break
            case "2Â°F":
                paramValue = 0x02
                break
            case "3Â°F":
                paramValue = 0x03
                break
            case "4Â°F":
                paramValue = 0x04
                break
            case "5Â°F":
                paramValue = 0x05
                break
            case "6Â°F":
                paramValue = 0x06
                break
            case "7Â°F":
                paramValue = 0x07
                break
            case "8Â°F":
                paramValue = 0x08
                break
            case "9Â°F":
                paramValue = 0x09
                break
            case "10Â°F":
                paramValue = 0x0A
                break
            default:
                paramValue = 0 // Default 0Â°F
	            break
        }

        //cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Check before
        cmds << zwave.configurationV2.configurationSet(parameterNumber: "${type}"()."${paramName}".Param, size: "${type}"()."${paramName}".Size, configurationValue: "${type}"(paramValue)."${paramName}".ParamValue)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Verify after
    }

    if (settings.swingZTS) {
        log.debug "Setting new value of Temp Swing to $settings.swingZTS"
        def paramName = "Swing"
        def paramValue
        switch (settings.swingZTS) {
            case "1.0Â°F":
                paramValue = 1
                break
            case "2.0Â°F":
                paramValue = 2
                break
            case "3.0Â°F":
                paramValue = 3
                break
            case "4.0Â°F":
                paramValue = 4
                break
            default:
                paramValue = 2 // Default 2.0Â°F / 1Â°C
	            break
        }

        //cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Check before
        cmds << zwave.configurationV2.configurationSet(parameterNumber: "${type}"()."${paramName}".Param, size: "${type}"()."${paramName}".Size, configurationValue: "${type}"(paramValue)."${paramName}".ParamValue)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Verify after
    }
    
    return cmds
}

private configureCT() {
    def cmds = []
    
    // Set Simple UI mode to enabled (otherwise it switches to per day schedule and doesn't work with ST)
    log.debug "Setting SimpleUI mode to enabled" // Enable SimpleUI otherwise thermostat doesn't work with ST
    //cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.SimpleUIMode.Param) // Check before
    cmds << zwave.configurationV2.configurationSet(parameterNumber: ctParamMap.SimpleUIMode.Param, size: ctParamMap.SimpleUIMode.Size, configurationValue: [ctParamMap.SimpleUIMode.Enabled])
    cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.SimpleUIMode.Param) // Verify after
    
    if (settings.autoTempDiffCT) {
        log.debug "Setting new value of Auto Temp Differential Report to $settings.autoTempDiffCT"
        def paramValue
        switch (settings.autoTempDiffCT) {
            case "Disabled":
                paramValue = 0
                break
            case "0.5Â°F":
                paramValue = 1
                break
            case "1.0Â°F":
                paramValue = 2
                break
            case "1.5Â°F":
                paramValue = 3
                break
            case "2.0Â°F":
                paramValue = 4
                break
            default:
                paramValue = ctParamMap.TempReport.Default // Default 1.0Â°F
	            break
        }

        //cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.TempReport.Param) // Check before
        cmds << zwave.configurationV2.configurationSet(parameterNumber: ctParamMap.TempReport.Param, size: ctParamMap.TempReport.Size, configurationValue: [paramValue])
        cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.TempReport.Param) // Verify after
    }

    if (settings.swingCT) {
        log.debug "Setting new value of Temp Swing to $settings.swingCT"
        def paramValue
        switch (settings.swingCT) {
            case "0.5Â°F":
                paramValue = 1
                break
            case "1.0Â°F":
                paramValue = 2
                break
            case "1.5Â°F":
                paramValue = 3
                break
            case "2.0Â°F":
                paramValue = 4
                break
            case "2.5Â°F":
                paramValue = 5
                break
            case "3.0Â°F":
                paramValue = 6
                break
            case "3.5Â°F":
                paramValue = 7
                break
            case "4.0Â°F":
                paramValue = 8
                break
            default:
                paramValue = ctParamMap.TempSwing.Default // Default 1.0Â°F
	            break
        }

        //cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.TempSwing.Param) // Check before
        cmds << zwave.configurationV2.configurationSet(parameterNumber: ctParamMap.TempSwing.Param, size: ctParamMap.TempSwing.Size, configurationValue: [paramValue])
        cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.TempSwing.Param) // Verify after
    }
    
    log.debug "Getting C-Wire state"
    cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.CWire.Param)
    
    log.debug "Getting Humidity Reporting Threshold"
    cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.HumidityReport.Param) // Check before
    
    return cmds
}

// Command Implementations
def configure() {
    log.trace "Configure called"

    // Bug with ST firmware 18.x, if device doesn't advertise secure capabilities in the CC list (0x98), ST doesn't so a secure association if required for device, so we have to complete the assocaition manually and set the channel to secure
    if (zwaveInfo.zw && !zwaveInfo.zw.contains("s")) {
        log.debug "Non-secure inclusion"
    } else {
        //log.debug "Secure inclusion"
        log.debug "Forcing secure channel inclusion and communication"
        state.sec = 1 // Bug with ST hub, doesn't invoke secure channel communication for ZTS-500 so force it if we are securely included
        //cmds << zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId) // Bug with device not publishing 0x98 in CC
    }

    // Identify and configure the thermostat
    log.trace "Device MSR: $state.MSR"
    runIn(30, refresh) // Give it some time and then run refresh
    delayBetween([
        //discoverConfigParameters(), // DEBUGGING
        zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
        zwave.versionV1.versionGet().format(),
        setConfigParameters()
    ], 2300)
}

def refresh() {
    // Force a refresh
    log.info "Requested a refresh"
    state.lastBatteryGet = (new Date().time) - (1440 * 60000)
    state.lastClockSet = (new Date().time) - (1440 * 60000)
    state.lastPollGet = (new Date().time) - (30 * 60000)

    def cmds = []
    
    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()
        cmds << zwave.versionV1.versionGet().format()
    } else {
        checkThermostatModel()
        log.trace "Device MSR: $state.MSR"
    }

    cmds << poll()
    
    sendHubCommand(response(delayBetween(cmds, 2100)).toHubAction()) // Send command since this can be called from a schedule
}

def scheduledPoll() {
    sendHubCommand(response(poll()).toHubAction()) // Send command since this can be called from a schedule
}

def poll() {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Z-Wave Thermostat with Temperature, Humidity and Auto Time Setting Device Handler"]) // Save DH Name for parent app

    def cmds = []
    def doPoll = false

    if (batterySaveMode) { // If we are in battery power save mode then we poll once it 30 minutes only
        log.trace "Battery save mode, fetching updates every 30 minutes"
        def nowTime = new Date().time
        def ageInMinutes = state.lastPollGet ? (nowTime - state.lastPollGet)/60000 : 30
        log.trace "Last poll ${ageInMinutes} minutes ago"
        if (ageInMinutes >= 30) {
            state.lastPollGet = nowTime
            log.info "Fetching fresh thermostate state"
            doPoll = true
        }
    } else {
        doPoll = true // no battery save, lets get the values
    }

    if (doPoll) {
        log.trace "Polling thermostat information"
        cmds << delayBetween([
            command(zwave.thermostatModeV2.thermostatModeSupportedGet()),
            command(zwave.thermostatFanModeV3.thermostatFanModeSupportedGet()),
            command(zwave.thermostatModeV2.thermostatModeGet()),
            command(zwave.thermostatFanModeV3.thermostatFanModeGet()),
            command(zwave.thermostatFanStateV1.thermostatFanStateGet()),
            command(zwave.sensorMultilevelV3.sensorMultilevelGet()), // current temperature
            command(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet()),
            command(zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1)),
            command(zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 2)),
            command(zwave.multiInstanceV1.multiInstanceCmdEncap(instance: 2).encapsulate(zwave.sensorMultilevelV3.sensorMultilevelGet())), // CT-100/101 Customization - Humidity is an encapsulated multilevel sensor get command, 2nd instance
            getBattery(),
            setClock(),
            getControls(),
            readFilter(),
        ], 2300)
    }
    else {
        log.trace "Poll called again to soon, skipping poll to save battery"
        sendEvent(name: "battery", value: device.currentValue("battery"), unit: "%", descriptionText: "Battery save mode", displayed: false, isStateChange: true) // We need to send something otherwise Poll dies if nothing is done
    }
    
    cmds
}

def levelUp() {
    log.trace "Level Up called"
    levelUpDown(1)
}

def levelDown() {
    log.trace "Level Down called"
    levelUpDown(-1)
}

def levelUpDown(value) {
    log.trace "levelUpDown called with value $value, current thermostat mode ${device.currentState("thermostatMode")?.value}"

    // NOTE: Bug in ST platform, for iOS devices we only get 0 (down) and 1 (up) for this control
    // For Android devices we get an absolute number showing the number of times up/down have been called since the page was opened (e.g. called up 4 times we get +4, if down then we get +3). If you open the page again and press up you get +1, if you close and open again and press down you get -1 (and the as long as the page is open it will be cumulative)

    // Determine which OS based on value behaviors (urrgghhh.....ST!)
    def upLevel
    if (!state.lastLevelUpDown)
    state.lastLevelUpDown = 0 // If it isn't defined lets baseline it

    if ((state.lastLevelUpDown == 1) && (value == 1)) // Last time it was 1 and again it's 1 its increase
    upLevel = true
    else if ((state.lastLevelUpDown == 0) && (value == 0)) // Last time it was 0 and again it's 0 then it's decrease
        upLevel = false
    else if ((state.lastLevelUpDown == -1) && (value == -1)) // Last time it was -1 and again it's -1 then it's decrease
        upLevel = false
    else if ((value - state.lastLevelUpDown) > 0) // If it's increasing then it's up
        upLevel = true
    else if ((value - state.lastLevelUpDown) < 0) // If it's decreasing then it's down
        upLevel = false
    else
        log.error "UNDEFINED STATE, CONTACT DEVELOPER. Last level $state.lastLevelUpDown, Current level, $value"

    state.lastLevelUpDown = value // Save it

    if (upLevel) { // Increase the current temperature (check heating or cooling mode)
        log.debug "Increasing temperature by 1Â°"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([raiseHeatingSetpoint(), raiseCoolSetpoint()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            raiseHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            raiseCoolSetpoint()
        }
    } else {
        log.debug "Reducing temperature by 1Â°"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([lowerHeatingSetpoint(), lowerCoolSetpoint()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            lowerHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            lowerCoolSetpoint()
        }
    }

    // NOTHING AFTER THE COMMANDS OR THE COMMANDS WONT WORK
}

def raiseHeatingSetpoint() {
    log.debug "Setting heat set point up"
	alterSetpoint(true, "heatingSetpoint")
}

def lowerHeatingSetpoint() {
    log.debug "Setting heat set point down"
	alterSetpoint(false, "heatingSetpoint")
}

def raiseCoolSetpoint() {
    log.debug "Setting cool set point up"
	alterSetpoint(true, "coolingSetpoint")
}

def lowerCoolSetpoint() {
    log.debug "Setting cool set point down"
	alterSetpoint(false, "coolingSetpoint")
}

// Adjusts nextHeatingSetpoint either .5Â° C/1Â° F) if raise true/false
def alterSetpoint(raise, setpoint) {
	def locationScale = getTemperatureScale()
	def deviceScale = (state.scale == 1) ? "F" : "C"
	def heatingSetpoint = getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = getTempInLocalScale("coolingSetpoint")
	def targetValue = (setpoint == "heatingSetpoint") ? heatingSetpoint : coolingSetpoint
	def delta = (locationScale == "F") ? 1 : 0.5
	targetValue += raise ? delta : - delta

	def data = enforceSetpointLimits(setpoint, [targetValue: targetValue, heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
	// update UI without waiting for the device to respond, this to give user a smoother UI experience
	// also, as runIn's have to overwrite and user can change heating/cooling setpoint separately separate runIn's have to be used
	if (data.targetHeatingSetpoint) {
		sendEvent("name": "heatingSetpoint", "value": getTempInLocalScale(data.targetHeatingSetpoint, deviceScale),
				unit: getTemperatureScale(), eventType: "ENTITY_UPDATE", displayed: false)
	}
	if (data.targetCoolingSetpoint) {
		sendEvent("name": "coolingSetpoint", "value": getTempInLocalScale(data.targetCoolingSetpoint, deviceScale),
				unit: getTemperatureScale(), eventType: "ENTITY_UPDATE", displayed: false)
	}
	if (data.targetHeatingSetpoint && data.targetCoolingSetpoint) {
		runIn(5, "updateHeatingSetpoint", [data: data, overwrite: true])
	} else if (setpoint == "heatingSetpoint" && data.targetHeatingSetpoint) {
		runIn(5, "updateHeatingSetpoint", [data: data, overwrite: true])
	} else if (setpoint == "coolingSetpoint" && data.targetCoolingSetpoint) {
		runIn(5, "updateCoolingSetpoint", [data: data, overwrite: true])
	}
}

def updateHeatingSetpoint(data) {
	updateSetpoints(data)
}

def updateCoolingSetpoint(data) {
	updateSetpoints(data)
}

def enforceSetpointLimits(setpoint, data) {
	def locationScale = getTemperatureScale() 
	def minSetpoint = (setpoint == "heatingSetpoint") ? getTempInDeviceScale(40, "F") : getTempInDeviceScale(50, "F")
	def maxSetpoint = (setpoint == "heatingSetpoint") ? getTempInDeviceScale(90, "F") : getTempInDeviceScale(99, "F")
	def deadband = device.currentValue("deadBand") ?: ((state.scale == 1) ? 1 : 1)  // Use device reported deadband otherwise use 1Â°F, 1Â°C - ST recommends 3 and 2, but lets keep it comfortable and practical
	def targetValue = getTempInDeviceScale(data.targetValue, locationScale)
	def heatingSetpoint = null
	def coolingSetpoint = null
	// Enforce min/mix for setpoints
	if (targetValue > maxSetpoint) {
		targetValue = maxSetpoint
	} else if (targetValue < minSetpoint) {
		targetValue = minSetpoint
	}
	// Enforce deadband between setpoints
	if (setpoint == "heatingSetpoint") {
		heatingSetpoint = targetValue 
		coolingSetpoint = (heatingSetpoint + deadband > getTempInDeviceScale(data.coolingSetpoint, locationScale)) ? heatingSetpoint + deadband : null
	}
	if (setpoint == "coolingSetpoint") {
		coolingSetpoint = targetValue
		heatingSetpoint = (coolingSetpoint - deadband < getTempInDeviceScale(data.heatingSetpoint, locationScale)) ? coolingSetpoint - deadband : null
	}
    log.trace "Enforcing deadband of ${deadband}Â°${locationScale} for request ${targetValue} ${setpoint}. Adjusted Settings -> ${heatingSetpoint ? "Heat: ${heatingSetpoint}" : ""} ${coolingSetpoint ? "Cool: ${coolingSetpoint}" : ""}"
	return [targetHeatingSetpoint: heatingSetpoint, targetCoolingSetpoint: coolingSetpoint]
}

def setHeatingSetpoint(degrees) {
	if (degrees) {
		state.heatingSetpoint = degrees.toDouble()
		runIn(2, "updateSetpoints", [overwrite: true])
	}
}

def setCoolingSetpoint(degrees) {
	if (degrees) {
		state.coolingSetpoint = degrees.toDouble()
		runIn(2, "updateSetpoints", [overwrite: true])
	}
}

def updateSetpoints() {
	def deviceScale = (state.scale == 1) ? "F" : "C"
	def data = [targetHeatingSetpoint: null, targetCoolingSetpoint: null]
	def heatingSetpoint = getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = getTempInLocalScale("coolingSetpoint")
	if (state.heatingSetpoint) {
		data = enforceSetpointLimits("heatingSetpoint", [targetValue: state.heatingSetpoint,
				heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
	}
	if (state.coolingSetpoint) {
		heatingSetpoint = data.targetHeatingSetpoint ? getTempInLocalScale(data.targetHeatingSetpoint, deviceScale) : heatingSetpoint
		coolingSetpoint = data.targetCoolingSetpoint ? getTempInLocalScale(data.targetCoolingSetpoint, deviceScale) : coolingSetpoint
		data = enforceSetpointLimits("coolingSetpoint", [targetValue: state.coolingSetpoint,
				heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
		data.targetHeatingSetpoint =  data.targetHeatingSetpoint ?: (state.heatingSetpoint ? getTempInDeviceScale(heatingSetpoint, getTemperatureScale()) : null)
	}
	state.heatingSetpoint = null
	state.coolingSetpoint = null
	updateSetpoints(data)
}

def updateSetpoints(data) {
    //log.trace "Setting setpoints: $data"
	def cmds = []
	if (data.targetHeatingSetpoint) {
		cmds << new physicalgraph.device.HubAction(command(zwave.thermostatSetpointV1.thermostatSetpointSet(
					setpointType: 1, scale: state.scale, precision: state.precision, scaledValue: data.targetHeatingSetpoint)))
	}
	if (data.targetCoolingSetpoint) {
		cmds << new physicalgraph.device.HubAction(command(zwave.thermostatSetpointV1.thermostatSetpointSet(
					setpointType: 2, scale: state.scale, precision: state.precision, scaledValue: data.targetCoolingSetpoint)))
	}
    cmds << new physicalgraph.device.HubAction(command(zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1)))
    cmds << new physicalgraph.device.HubAction(command(zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 2)))
    cmds << new physicalgraph.device.HubAction(command(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet())) // Bug CT-XX doesn't report change in thermostat operating state

	sendHubCommand(cmds)
}

// thermostatSetpoint is not displayed by any tile as it can't be predictable calculated due to
// the device's quirkiness but it is defined by the capability so it must be set, set it to the most likely value
def updateThermostatSetpoint(setpoint, value) {
	def scale = getTemperatureScale()
	def heatingSetpoint = (setpoint == "heatingSetpoint") ? value : getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = (setpoint == "coolingSetpoint") ? value : getTempInLocalScale("coolingSetpoint")
	def mode = device.currentValue("thermostatMode")
	def thermostatSetpoint = heatingSetpoint    // corresponds to (mode == "heat" || mode == "emergency heat")
	if (mode == "cool") {
		thermostatSetpoint = coolingSetpoint
	} else if (mode == "auto" || mode == "off") {
		// Set thermostatSetpoint to the setpoint closest to the current temperature
		def currentTemperature = getTempInLocalScale("temperature")
		if (currentTemperature > (heatingSetpoint + coolingSetpoint)/2) {
			thermostatSetpoint = coolingSetpoint
		}
	}
	sendEvent(name: "thermostatSetpoint", value: thermostatSetpoint, unit: getTemperatureScale())
}

def switchMode() {
	def currentMode = device.currentValue("thermostatMode")
	def supportedModes = state.supportedModes
	// Old version of supportedModes was as string, make sure it gets updated
	if (supportedModes && supportedModes.size() && supportedModes[0].size() > 1) {
		def next = { supportedModes[supportedModes.indexOf(it) + 1] ?: supportedModes[0] }
		def nextMode = next(currentMode)
		runIn(2, "setGetThermostatMode", [data: [nextMode: nextMode], overwrite: true])
	} else {
		log.warn "supportedModes not defined"
		getSupportedModes()
	}
}

def switchToMode(nextMode) {
	def supportedModes = state.supportedModes
	// Old version of supportedModes was as string, make sure it gets updated
	if (supportedModes && supportedModes.size() && supportedModes[0].size() > 1) {
		if (supportedModes.contains(nextMode)) {
			runIn(2, "setGetThermostatMode", [data: [nextMode: nextMode], overwrite: true])
		} else {
			log.debug("ThermostatMode $nextMode is not supported by ${device.displayName}")
		}
	} else {
		log.warn "supportedModes not defined"
		getSupportedModes()
	}
}

def getSupportedModes() {
	def cmds = []
	cmds << new physicalgraph.device.HubAction(command(zwave.thermostatModeV2.thermostatModeSupportedGet()))
	sendHubCommand(cmds)
}

def switchFanMode() {
	def currentMode = device.currentValue("thermostatFanMode")
	def supportedFanModes = state.supportedFanModes
	// Old version of supportedFanModes was as string, make sure it gets updated
	if (supportedFanModes && supportedFanModes.size() && supportedFanModes[0].size() > 1) {
		def next = { supportedFanModes[supportedFanModes.indexOf(it) + 1] ?: supportedFanModes[0] }
		def nextMode = next(currentMode)
		runIn(2, "setGetThermostatFanMode", [data: [nextMode: nextMode], overwrite: true])
	} else {
		log.warn "supportedFanModes not defined"
		getSupportedFanModes()
	}
}

def switchToFanMode(nextMode) {
	def supportedFanModes = state.supportedFanModes
	// Old version of supportedFanModes was as string, make sure it gets updated
	if (supportedFanModes && supportedFanModes.size() && supportedFanModes[0].size() > 1) {
		if (supportedFanModes.contains(nextMode)) {
			runIn(2, "setGetThermostatFanMode", [data: [nextMode: nextMode], overwrite: true])
		} else {
			log.debug("FanMode $nextMode is not supported by ${device.displayName}")
		}
	} else {
		log.warn "supportedFanModes not defined"
		getSupportedFanModes()
	}
}

def getSupportedFanModes() {
	def cmds = [new physicalgraph.device.HubAction(command(zwave.thermostatFanModeV3.thermostatFanModeSupportedGet()))]
	sendHubCommand(cmds)
}

def getModeMap() { [
	"off": 0,
	"heat": 1,
	"cool": 2,
	"auto": 3,
	"emergency heat": 4
]}

def setThermostatMode(String value) {
	switchToMode(value)
}

def setGetThermostatMode(data) {
	def cmds = [new physicalgraph.device.HubAction(command(zwave.thermostatModeV2.thermostatModeSet(mode: modeMap[data.nextMode]))),
			new physicalgraph.device.HubAction(command(zwave.thermostatModeV2.thermostatModeGet())),
            new physicalgraph.device.HubAction(command(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet()))] // Get Operating mode, thermostat doesn't always report it
	sendHubCommand(cmds)
}

def getFanModeMap() { [
	"auto": 0,
	"on": 1,
	"circulate": 6
]}

def setThermostatFanMode(String value) {
	switchToFanMode(value)
}

def setGetThermostatFanMode(data) {
	def cmds = [new physicalgraph.device.HubAction(command(zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: fanModeMap[data.nextMode]))),
			new physicalgraph.device.HubAction(command(zwave.thermostatFanModeV3.thermostatFanModeGet())),
            new physicalgraph.device.HubAction(command(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet()))] // Get Operating mode, thermostat doesn't always report it
	sendHubCommand(cmds)
}

def off() {
	switchToMode("off")
}

def heat() {
	switchToMode("heat")
}

def emergencyHeat() {
	switchToMode("emergency heat")
}

def cool() {
	switchToMode("cool")
}

def auto() {
	switchToMode("auto")
}

def fanOn() {
	switchToFanMode("on")
}

def fanAuto() {
	switchToFanMode("auto")
}

def fanCirculate() {
	switchToFanMode("circulate")
}

// Get stored temperature from currentState in current local scale
def getTempInLocalScale(state) {
	def temp = device.currentState(state)
	if (temp && temp.value && temp.unit) {
		return getTempInLocalScale(temp.value.toBigDecimal(), temp.unit)
	}
	return 0
}

// get/convert temperature to current local scale
def getTempInLocalScale(temp, scale) {
	if (temp && scale) {
		def scaledTemp = convertTemperatureIfNeeded(temp.toBigDecimal(), scale).toDouble()
		return (getTemperatureScale() == "F" ? scaledTemp.round(0).toInteger() : roundC(scaledTemp))
	}
	return 0
}

def getTempInDeviceScale(state) {
	def temp = device.currentState(state)
	if (temp && temp.value && temp.unit) {
		return getTempInDeviceScale(temp.value.toBigDecimal(), temp.unit)
	}
	return 0
}

def getTempInDeviceScale(temp, scale) {
	if (temp && scale) {
		def deviceScale = (state.scale == 1) ? "F" : "C"
		return (deviceScale == scale) ? temp :
				(deviceScale == "F" ? celsiusToFahrenheit(temp).toDouble().round(0).toInteger() : roundC(fahrenheitToCelsius(temp)))
	}
	return 0
}

def roundC (tempC) {
	return (Math.round(tempC.toDouble() * 2))/2
}

private checkThermostatModel() {
    state.defectiveClock = false // Reset incase the user upgraded the Z-Wave module
    state.noBattery = false // Reset incase user upgraded module
    
    switch (state.MSR) {
        case "008B-5452-5433": // Trane Z-Wave Thermostat
            log.debug "Found Trane Z-Wave Thermostat"
            sendEvent(name:"thermostatModel", value:"Trane", displayed: true)
            break

        case "5254-0200-8031": // ZTS-110
            log.debug "Found ZTS-110 Thermostat"
            sendEvent(name:"thermostatModel", value:"ZTS-110", displayed: true)
            break

        case "5254-0200-8170": // ZTS-500
            log.debug "Found ZTS-500 Thermostat"
            sendEvent(name:"thermostatModel", value:"ZTS-500", displayed: true)
            break

        case "0098-6402-0100": //CT-100 Plus Radio Thermostat
            log.debug "Found CT-100 Plus Radio Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-100+", displayed: true)
            break

        case "0098-6401-0107": //CT-100
        case "0098-6401-0106": //CT-100 Vivint
            log.debug "Found CT-100 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-100", displayed: true)
            break

        case "0098-6501-000C": //CT-101 (lowe's model)
            log.debug "Found CT-101 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-101", displayed: true)
            break

        case "0098-5003-0109": //CT-80
        case "0098-5003-01FD": //CT-80
            log.debug "Found CT-80 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-80", displayed: true)
            state.noBattery = true // This model has no battery
            break

        case "0098-3200-015E": //CT-50 (Filtrete 3M-50)
            log.debug "Found CT-50 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-50", displayed: true)
            break

        case "0098-1E10-0158": //CT-30
        case "0098-1E12-015C": //CT-30e
        case "0098-0000-0000": //CT-30 (local alarm company model)
        case "0098-1E12-015E": //CT-30 Rev C1
        case "0098-0001-001E": //CT-30 APX
        case "0098-0001-0000": //CT-30 Amazon Brown Box
        case "0098-0001-00FF": //CT-30 Amazon Brown Box
            log.debug "Found CT-30 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-30", displayed: true)
            break

        default:
            log.debug "Unknown thermostat with MSR $state.MSR"
            sendEvent(name:"thermostatModel", value:"Unknown thermostat with MSR $state.MSR", displayed: true)
            break
    }
    
    // Check for defective clock models
    def applicationVersion = getDataValue("fw")?.tokenize('.')?.first() as Integer
    if ((state.MSR?.startsWith("0098-1E12-015C") && (applicationVersion <= 8)) ||
        (state.MSR?.startsWith("0098-5003-0109") && (applicationVersion <= 9)) ||
        (state.MSR?.startsWith("0098-5003-01FD") && (applicationVersion <= 9))
       ) {
        state.defectiveClock = true
    }
}

// Get battery
private getBattery() {
    def cmds = []
    def nowTime = new Date().time
    def ageInMinutes = state.lastBatteryGet ? (nowTime - state.lastBatteryGet)/60000 : 1440 // Once every 24 hours
    log.trace "Battery report age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
        state.lastBatteryGet = nowTime
        log.debug "Fetching fresh battery value"
        cmds << zwave.batteryV1.batteryGet()
        if (isCT()) {
            log.debug "Fetching C-wire status"
            cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.CWire.Param) // Get C-Wire state
        }
    }
    
    cmds ? commands(cmds, 2000) : []
}

// Set clock on device
private setClock() {
    def cmds = []
    
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendEvent(name: "InvalidTimezone", value: "InvalidTimezone", descriptionText: "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately", isStateChange: true, displayed: true)
    }

    def nowTime = new Date().time
    def ageInMinutes = state.lastClockSet ? (nowTime - state.lastClockSet)/60000 : 1440 // Once a day
    log.trace "Clock set age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
        state.lastClockSet = nowTime
        def nowCal = Calendar.getInstance(timeZone) // get current location timezone
        if (state.defectiveClock) {
            log.warn "Found CT-XXX with defective firmware, setting clock in day into the past"
            nowCal.add(Calendar.DAY_OF_MONTH, -1) // the thermostat with defective firmware shows it one day into the future to send one day in the past to get correct day
        }
        log.debug "Setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", timeZone)}"
        sendEvent(descriptionText: "Setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", timeZone)}", isStateChange:true, displayed: true)
        cmds << zwave.clockV1.clockSet(hour: nowCal.get(Calendar.HOUR_OF_DAY), minute: nowCal.get(Calendar.MINUTE), weekday: nowCal.get(Calendar.DAY_OF_WEEK))
    }
    
    cmds ? commands(cmds, 2000) : []
}

def discoverConfigParameters() {
    log.trace "Discovering the first 15 configuration parameters"

    def cmds = []
    (1..15).each { param ->
        cmds << command(zwave.configurationV2.configurationGet(parameterNumber: param)) // Check before
    }
    delayBetween(cmds, 2000)
}

// Checks if it's a ZTS thermostat
private isZTS() {
    state.MSR?.startsWith("5254-0200") ? true : false
}

// Checks if it's a CT thermostat
private isCT() {
    state.MSR?.startsWith("0098") ? true : false
}

// Legacy for backward compatibility
def quickSetCool(degrees) {
    setCoolingSetpoint(degrees)
}

def quickSetHeat(degrees) {
    setHeatingSetpoint(degrees)
}

// Partial Lock controls on physical device
def partialLockControls() {
    def cmds = []
    if (isCT()) {
        log.debug "Partically locking controls"
        cmds << zwave.configurationV2.configurationSet(parameterNumber: ctParamMap.UtilityLock.Param, size: ctParamMap.UtilityLock.Size, configurationValue: [ctParamMap.UtilityLock.Partial])
        cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.UtilityLock.Param) // Verify after
        sendEvent(name: "lockControls", value: "partial", descriptionText: "Thermostat controls partially locked") // TODO: Device doesn't currently read back on this parameter so assume it's done for now
        sendEvent(name: "sharedTile1", value: "partial", displayed: false)
    } else {
        log.warn "This device does not support partial locking controls"
    }
    
    cmds ? commands(cmds, 2000) : []
}

// Full Lock controls on physical device
def lockControls() {
    def cmds = []
    if (isCT()) {
        log.debug "Fully locking controls"
        cmds << zwave.configurationV2.configurationSet(parameterNumber: ctParamMap.UtilityLock.Param, size: ctParamMap.UtilityLock.Size, configurationValue: [ctParamMap.UtilityLock.Full])
        cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.UtilityLock.Param) // Verify after
        sendEvent(name: "lockControls", value: "full", descriptionText: "Thermostat controls fully locked") // TODO: Device doesn't currently read back on this parameter so assume it's done for now
        sendEvent(name: "sharedTile1", value: "full", displayed: false)
    } else {
        log.warn "This device does not support locking controls"
    }
    
    cmds ? commands(cmds, 2000) : []
}

// Unlock controls on physical device
def unlockControls() {
    def cmds = []
    if (isCT()) {
        log.debug "Unlocking controls"
        cmds << zwave.configurationV2.configurationSet(parameterNumber: ctParamMap.UtilityLock.Param, size: ctParamMap.UtilityLock.Size, configurationValue: [ctParamMap.UtilityLock.Disabled])
        cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.UtilityLock.Param) // Verify after
        sendEvent(name: "lockControls", value: "disabled", descriptionText: "Thermostat controls unlocked") // TODO: Device doesn't currently read back on this parameter so assume it's done for now
        sendEvent(name: "sharedTile1", value: "disabled", displayed: false)
    } else {
        log.warn "This device does not support unlocking controls"
    }
    
    cmds ? commands(cmds, 2000) : []
}

// Get the status of controls of physical device
private getControls() {
    def cmds = []
    
    if (isCT()) {
        log.debug "Getting status of controls"
        // TODO: Device doesn't currently read back on this parameter so assume it's enabled for now
        if (!device.currentValue("lockControls")) { // If it's not initialized assume it's disabled
            sendEvent(name: "lockControls", value: "disabled")
        }
        if (!device.currentValue("sharedTile1") || (device.currentValue("sharedTile1") == "unsupported")) { // If it's not initialized assume it's disabled
            sendEvent(name: "sharedTile1", value: "disabled", displayed: false)
        }
        cmds << zwave.configurationV2.configurationGet(parameterNumber: ctParamMap.UtilityLock.Param)
    } else {
        log.trace "This devices does not support locking controls"
    }
    
    cmds ? commands(cmds, 2000) : []
}

// Reset filter counter on device
def resetFilter() {
    def cmds = []
    def type
    switch (state.MSR) {
        case "5254-0200-8170": // ZTS-500
            type = "getZts500ParamMap"
            break

        case "5254-0200-8031": // ZTS-110
            type = "getZts100ParamMap"
            break
        
        default:
            log.warn "Filter reset counter unsupported on model ${state.MSR}"
            sendEvent(name:"sharedTile1", value: "unsupported", displayed: false)
            return []
    }

    def paramName = "SetFilter"
    def paramValue

    if (settings.filterZTS) {
        paramValue = settings.filterZTS
        if (type == "getZts100ParamMap") { // This has to be in multiple of 100 hours
            paramValue = Math.round(paramValue/100) * 100 // Round up to the nearest 100
        }
    } else {
        paramValue = "${type}"()."${paramName}".Default
    }

    log.debug "Resetting filter counter to $paramValue hours"

    //cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Check before
    cmds << zwave.configurationV2.configurationSet(parameterNumber: "${type}"()."${paramName}".Param, size: "${type}"()."${paramName}".Size, configurationValue: "${type}"(paramValue)."${paramName}".ParamValue)
    cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Verify after
    
    if (type == "getZts500ParamMap") { // ZTS-500 Needs an extra reset to clear the screen
        cmds << zwave.configurationV2.configurationSet(parameterNumber: zts500ParamMap.ResetFilter.Param, size: zts500ParamMap.ResetFilter.Size, configurationValue: [zts500ParamMap.ResetFilter.Enabled])
    }
    
    paramName = "ReportFilter" // Read the new value
    cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param)
    
    cmds ? commands(cmds, 2000) : []
}

// Read filter counter on device
private readFilter() {
    if (!isZTS()) {
        log.trace "This devices does not support filter usage"
        return []
    }

    def cmds = []
    def type
    switch (state.MSR) {
        case "5254-0200-8170": // ZTS-500
            type = "getZts500ParamMap"
            break

        case "5254-0200-8031": // ZTS-110
            type = "getZts100ParamMap"
            break
        
        default:
            log.warn "Filter counter unsupported on model ${state.MSR}"
            sendEvent(name:"sharedTile1", value: "unsupported", displayed: false)
            return []
    }

    def paramName = "ReportFilter"
    def paramValue

    log.debug "Reading filter counter remaining hours"

    cmds << zwave.configurationV2.configurationGet(parameterNumber: "${type}"()."${paramName}".Param) // Read value
    
    cmds ? commands(cmds, 2000) : []
}

private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }
        
    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }
    
    //log.debug ret as Integer[]
    
    return ret as Integer[] // We need an integer array
}

private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }
        
    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }
    
    //log.debug ret
    
    return ret
}

private getCtParamMap(value = null) {
	[
        "TempReport":		[ Param: 1, Size: 1, Default: 2, Min: 0, Max: 4, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "UtilityLock": 		[ Param: 3, Size: 1, Default: 0, Full: 2, Partial: 1, Disabled: 0 ],
        "CWire": 			[ Param: 4, Size: 1, Default: 2, Enabled: 1, Disabled: 2 ],
        "HumidityReport":	[ Param: 5, Size: 1, Default: 2, Min: 0, Max: 3, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "EmergencyHeat": 	[ Param: 6, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ],
        "TempSwing":		[ Param: 7, Size: 1, Default: 2, Min: 1, Max: 8, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "DiffTemp":			[ Param: 8, Size: 1, Default: 4, Min: 4, Max: 12, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "RecoveryMode": 	[ Param: 9, Size: 1, Default: 2, Min: 1, Max: 2, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "SimpleUIMode": 	[ Param: 11, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ],
        "MulticastMode": 	[ Param: 12, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ],
	]
}

private getZts500ParamMap(value = null) {
	[
        "TempScaleInF":		[ Param: 1, Size: 1, Default: 1, Min: 0, Max: 1, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "Swing": 			[ Param: 2, Size: 1, Default: 2, Min: 0, Max: 4, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "DeadBand": 		[ Param: 4, Size: 1, Default: 4, Min: 3, Max: 6, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ResetFilter": 		[ Param: 7, Size: 1, Default: 0, Enabled: 0, Disabled: 0 ],
        "SetFilter":		[ Param: 8, Size: 2, Default: 500, Min: 500, Max: 4000, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ReportFilter":		[ Param: 9, Size: 2, Default: 0, Min: 0, Max: 9999, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "TempOffset":		[ Param: 10, Size: 1, Default: 0, Min: 0, Max: 0xFF, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "TempAutoReport":	[ Param: 14, Size: 1, Default: 2, Min: 0, Max: 8, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}

private getZts100ParamMap(value = null) {
	[
        "Swing": 			[ Param: 1, Size: 1, Default: 2, Min: 0, Max: 4, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "SetFilter":		[ Param: 3, Size: 2, Default: 500, Min: 500, Max: 4000, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ReportFilter":		[ Param: 4, Size: 2, Default: 0, Min: 0, Max: 9999, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "TempAutoReport":	[ Param: 11, Size: 1, Default: 4, Min: 0, Max: 8, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "TempOffset":		[ Param: 13, Size: 1, Default: 0, Min: 0, Max: 0xFF, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}


// THIS IS THE END OF THE FILE